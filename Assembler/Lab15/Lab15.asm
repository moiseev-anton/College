.model tiny         ; Определение типа памяти
.stack 100h         ; Установка размера стека
.data               ; Сегмент данных
outStr db '0000$'   ; Выходная строка
SumOfDiff dw 0
SumOfEqual dw 0
NumOfDiff dw 0
NumOfEqual dw 0
.code            ; Сегмент кода, начало программы
jmp start        ; Переход к метке start

translByte proc  ; Процедура translByte для перевода байта
; Входные данные для процедуры translByte:
; AL - байт, который нужно перевести
; Выходные данные:
; BX - смещение строки в первые два байта, куда будет записан результат
push ax                  ; Сохранение содержимого регистра AX в стеке
push ax                  ; Дублирование содержимого регистра AX в стеке для последующих операций
shr al, 4                ; Сдвиг вправо на 4
cmp al, 9                ; Сравнение с 9
ja greater10             ; Если больше, переход к метке greater10
mov byte ptr [bx], '0'   ; Запись значения '0' в память по адресу, указанному в BX
add [bx], al             ; Добавление к содержимому по адресу в BX значения из AL
jmp next4Bit             ; Переход к метке next4Bit
greater10:               ; Метка greater10
mov byte ptr [bx], 'A'   ; Запись значения 'A' в память по адресу, указанному в BX
sub al, 10               ; Вычитание 10 из AL
add [bx], al             ; Добавление к содержимому по адресу в BX значения из AL
next4Bit:                ; Метка next4Bit
pop ax                   ; Восстановление значения регистра AX из стека
and al, 0Fh              ; Побитовая конъюнкция с 0Fh (00001111)
cmp al, 9                ; Сравнение с 9
ja _greater10            ; Если больше, переход к метке _greater10
mov byte ptr [bx + 1], '0' ; Запись значения '0' в память по адресу (BX + 1)
add [bx + 1], al         ; Прибавление AL к содержимому по адресу (BX + 1)
jmp exitByteProc         ; Переход к выходу из процедуры
_greater10:              ; Метка _greater10
mov byte ptr [bx + 1], 'A' ; Запись значения 'A' в память по адресу (BX + 1)
sub al, 10               ; Вычитание 10 из AL
add [bx + 1], al         ; Прибавление AL к содержимому по адресу (BX + 1)
exitByteProc:            ; Метка выхода из процедуры
pop ax                   ; Восстановление значения регистра AX из стека
ret                      ; Возврат из процедуры translByte
translByte endp          ; Конец процедуры translByte

translWord proc ; Процедура translWord для перевода слова
push ax         ; Сохранение содержимого регистра AX в стеке
push ax         ; Дублирование содержимого регистра AX в стеке для последующих операций
shr ax, 8       ; Сдвиг вправо на 8
call translByte ; Вызов процедуры translByte для обработки старшего байта
pop ax          ; Восстановление значения регистра AX из стека
and ax, 00FFh   ; Побитовая конъюнкция с 00FFh (0000000011111111)
add bx, 2       ; Увеличение BX на 2
call translByte ; Вызов процедуры translByte для обработки младшего байта
sub bx, 2       ; Уменьшение BX на 2
pop ax          ; Восстановление значения регистра AX из стека
ret             ; Возврат из процедуры translWord
translWord endp ; Конец процедуры translWord

start:              ; Точка входа программы
mov ax, @data       ; Установка регистра AX для настройки сегмента данных
mov ds, ax          ; Установка сегмента данных
mov bx, offset outStr ; Установка BX для строки outStr
mov ax, 60000       ; Установка значения AX
call translWord     ; Вызов процедуры translWord
mov ah, 9           ; Установка номера функции для вывода строки на экран
mov dx, offset outStr ; Установка DX для строки outStr
int 21h             ; Вызов прерывания для вывода строки
mov ax, 4c00h       ; Установка номера функции завершения программы
int 21h             ; Вызов прерывания для завершения программы
end start         